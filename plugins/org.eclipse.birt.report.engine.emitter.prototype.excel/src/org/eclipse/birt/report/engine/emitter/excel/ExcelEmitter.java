/*******************************************************************************
 * Copyright (c) 2006 Inetsoft Technology Corp.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Inetsoft Technology Corp  - Implementation
 *******************************************************************************/

package org.eclipse.birt.report.engine.emitter.excel;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.eclipse.birt.report.engine.api.IHTMLActionHandler;
import org.eclipse.birt.report.engine.api.RenderOptionBase;
import org.eclipse.birt.report.engine.api.impl.Action;
import org.eclipse.birt.report.engine.content.IAutoTextContent;
import org.eclipse.birt.report.engine.content.ICellContent;
import org.eclipse.birt.report.engine.content.IContainerContent;
import org.eclipse.birt.report.engine.content.IContent;
import org.eclipse.birt.report.engine.content.IDataContent;
import org.eclipse.birt.report.engine.content.IForeignContent;
import org.eclipse.birt.report.engine.content.IGroupContent;
import org.eclipse.birt.report.engine.content.IHyperlinkAction;
import org.eclipse.birt.report.engine.content.IImageContent;
import org.eclipse.birt.report.engine.content.ILabelContent;
import org.eclipse.birt.report.engine.content.IListBandContent;
import org.eclipse.birt.report.engine.content.IListContent;
import org.eclipse.birt.report.engine.content.IListGroupContent;
import org.eclipse.birt.report.engine.content.IPageContent;
import org.eclipse.birt.report.engine.content.IReportContent;
import org.eclipse.birt.report.engine.content.IRowContent;
import org.eclipse.birt.report.engine.content.IStyle;
import org.eclipse.birt.report.engine.content.ITableBandContent;
import org.eclipse.birt.report.engine.content.ITableContent;
import org.eclipse.birt.report.engine.content.ITableGroupContent;
import org.eclipse.birt.report.engine.content.ITextContent;
import org.eclipse.birt.report.engine.emitter.IContentEmitter;
import org.eclipse.birt.report.engine.emitter.IEmitterServices;
import org.eclipse.birt.report.engine.emitter.excel.chart.ChartConverter;
import org.eclipse.birt.report.engine.ir.CellDesign;
import org.eclipse.birt.report.engine.ir.DataItemDesign;
import org.eclipse.birt.report.engine.ir.ExtendedItemDesign;
import org.eclipse.birt.report.engine.ir.Report;
import org.eclipse.birt.report.engine.ir.TableGroupDesign;
import org.eclipse.birt.report.engine.layout.pdf.util.HTML2Content;
import org.eclipse.birt.report.engine.presentation.ContentEmitterVisitor;
import org.eclipse.birt.report.model.api.ExtendedItemHandle;

public class ExcelEmitter implements IContentEmitter
{

	public final static int MAXROW = 65025;

	public final static String OUTPUT_FORMAT = "xls";

	protected static Logger logger = Logger.getLogger( ExcelEmitter.class
			.getName( ) );

	private IEmitterServices eservice = null;

	private int[] width;

	private Map design2ExcelSpan = null;

	private Map table2TableBinding = null;

	private Map formulaDatas = new HashMap( );

	private final String EMPTY = " ";

	private final int INVALID = -1;

	private Stack groupInfos = new Stack( );

	private Stack tableBindings = new Stack( );

	private int lines = 0, flushLength = 1000;

	private StyleEngine engine = null;

	private ListBuffer lb;

	private OutputStream out = null;

	private List charts = new ArrayList( );

	private ChartConverter chartConverter = new ChartConverter( );

	public void end( IReportContent report )
	{
		try
		{
			//Make sure all dataes are swap out before export.
			lb.flush( true, engine );

			ExcelWriter writer = new ExcelWriter( out );
			writer.writeDeclarations( );
			writer.declareStyles( engine.getStyleIDMap( ) );
			writer.startSheet( );
			writer.startTable( width );
			writeDatas( writer );
			writer.endTable( );
			writer.closeSheet( );

			//Append sheets generated by charts.
			for ( int i = 0; i < charts.size( ); i++ )
			{
				File temp = (File) charts.get( i );
				writer.insert( temp );
				temp.delete( );
			}

			writer.close( true );
		}
		catch ( Exception e )
		{
			logger.log( Level.WARNING, e.getMessage( ), e );
			throw new RuntimeException( "Error Occur!" );
		}
	}

	public void endCell( ICellContent cell )
	{

	}

	public void endContainer( IContainerContent container )
	{
		endCase( );
	}

	public void endContent( IContent content )
	{
	}

	public void endGroup( IGroupContent group )
	{

	}

	public void endList( IListContent list )
	{
		endCase( );
	}

	public void endListBand( IListBandContent listBand )
	{

	}

	public void endListGroup( IListGroupContent group )
	{

	}

	public void endPage( IPageContent page )
	{

	}

	/**
	 * 1. calculate styles for this row top border
	 * 2. make sure all columns's size are same
	 * 3. judge if need swap dataes.
	 * 
	 * @param row row content
	 */
	public void endRow( IRowContent row )
	{
		engine.calculateTopStyles( );
		synchronizeCols( );

		if ( ++lines % flushLength == 0 )
		{
			try
			{
				lb.flush( false, engine );
			}
			catch ( Exception e )
			{
				logger.log( Level.WARNING, e.getMessage( ), e );
				throw new RuntimeException( "Error Occur" );
			}
		}
	}

	/**
	 * when a container element complete, 
	 * the bottom border's style can be calculated.  
	 */
	private void endCase( )
	{
		engine.calculateBottomStyles( );
	}

	/**
	 * 1. calculate the binding information.
	 * 2. complete the table.
	 * @param table
	 * 				table element 
	 */
	public void endTable( ITableContent table )
	{
		TableBinding tb = (TableBinding) table2TableBinding.get( table
				.getGenerateBy( ) );

		if ( tb != null )
		{
			GroupInfo gi = (GroupInfo) groupInfos.pop( );
			tb.compute( gi );
			tb.dump( formulaDatas );

			tableBindings.pop( );
		}

		endCase( );
	}

	public void endTableBand( ITableBandContent band )
	{
	}

	public void endTableGroup( ITableGroupContent group )
	{
		groupInfos.pop( );
	}

	public String getOutputFormat( )
	{
		return OUTPUT_FORMAT;
	}

	public void initialize( IEmitterServices service )
	{
		eservice = service;
		if ( service != null )
		{
			Object fd = eservice.getOption( RenderOptionBase.OUTPUT_FILE_NAME );
			File file = null;

			if ( fd != null )
			{
				try
				{
					file = new File( fd.toString( ) );
					File parent = file.getParentFile( );
					if ( parent != null && !parent.exists( ) )
					{
						parent.mkdirs( );
					}
					out = new BufferedOutputStream( new FileOutputStream( file ) );
				}
				catch ( FileNotFoundException e )
				{
					logger.log( Level.WARNING, e.getMessage( ), e );
				}
			}
		}

		if ( out == null )
		{
			Object val = eservice.getOption( RenderOptionBase.OUTPUT_STREAM );
			if ( val != null && val instanceof OutputStream )
			{
				out = (OutputStream) val;
			}
		}
	}

	public void start( IReportContent report )
	{
		Report r = report.getDesign( );
		ReportItemWidthVisitor visitor = new ReportItemWidthVisitor( r );

		width = visitor.getColumnsWidth( );
		design2ExcelSpan = visitor.getDesign2ExcelSpan( );
		table2TableBinding = visitor.getTable2TableBinding( );

		try
		{
			int delta = 2;
			lb = new DeltaListBuffer( width.length, delta );
			engine = StyleEngine.createStyleEngine( lb );
		}
		catch ( Exception e )
		{
			logger.log( Level.WARNING, e.getMessage( ), e );
			throw new RuntimeException( "Error occur!" );
		}
	}

	public void startAutoText( IAutoTextContent autoText )
	{
		String url = parseHyperLink( autoText );
		addData( autoText.getGenerateBy( ), autoText.getComputedStyle( ), url,
				autoText.getText( ) );
	}

	public void startCell( ICellContent cell )
	{
		CellDesign design = (CellDesign) cell.getGenerateBy( );

		if ( design.getContentCount( ) == 0 )
		{
			addData( design, cell.getComputedStyle( ), null, EMPTY );
		}
	}

	public void startContainer( IContainerContent container )
	{

	}

	public void startContent( IContent content )
	{

	}

	public void startData( IDataContent data )
	{
		String url = parseHyperLink( data );
		addData( data.getGenerateBy( ), data.getComputedStyle( ), url, data
				.getText( ) );
	}

	public void startForeign( IForeignContent foreign )
	{
		if ( IForeignContent.HTML_TYPE.equalsIgnoreCase( foreign.getRawType( ) ) )
		{
			HTML2Content convert = new HTML2Content( foreign.getReportContent( )
					.getDesign( ).getReportDesign( ) );
			convert.html2Content( foreign );
			ContentEmitterVisitor contentVisitor = new ContentEmitterVisitor(
					this );
			contentVisitor.visitChildren( foreign, null );

			startCase( foreign );
		}

	}

	public void startGroup( IGroupContent group )
	{

	}

	/**
	 * If the image is generaged by chart, get the chart data and store them
	 * @param image
	 * 				iamge element
	 */
	public void startImage( IImageContent image )
	{
		if ( image.getGenerateBy( ) instanceof ExtendedItemDesign )
		{
			ExtendedItemDesign eitem = (ExtendedItemDesign) image
					.getGenerateBy( );
			ExtendedItemHandle handle = (ExtendedItemHandle) eitem.getHandle( );
			String tagName = handle.getExtensionName( );

			if ( "chart".equalsIgnoreCase( tagName ) )
			{
				File res = chartConverter.convert( eitem, handle );

				if ( res != null )
				{
					charts.add( res );
				}
			}
		}

		//Although image are not showed in Excel, 
		//we have to add an empty to dataes to avoid exceptions 
		addData( image.getGenerateBy( ), image.getComputedStyle( ), null, EMPTY );
	}

	public void startLabel( ILabelContent label )
	{
		//elements generated by foreignexecutor have no direct design
		Object design = label.getGenerateBy( );
		IContent container = label;
		while ( design == null )
		{
			container = (IContent) container.getParent( );
			design = ( (IContent) container ).getGenerateBy( );
		}

		String url = parseHyperLink( label );

		addData( design, label.getComputedStyle( ), url, label.getText( ) );
	}

	public void startList( IListContent list )
	{
		startCase( list );
	}

	public void startListBand( IListBandContent listBand )
	{

	}

	public void startListGroup( IListGroupContent group )
	{

	}

	public void startPage( IPageContent page )
	{

	}

	public void startRow( IRowContent row )
	{

	}

	/**
	 * Calculate the left or right border's style.
	 * 
	 * @param content
	 */

	private void startCase( IContent content )
	{
		Span span = (Span) design2ExcelSpan.get( content.getGenerateBy( ) );
		engine.addContainerStyle( content.getComputedStyle( ), span, lb
				.getListSize( span.getCol( ) ) );
	}

	public void startTable( ITableContent table )
	{
		TableBinding tb = (TableBinding) table2TableBinding.get( table
				.getGenerateBy( ) );
		// some table generated by GridItemDesign
		if ( tb != null )
		{
			groupInfos
					.push( new GroupInfo( "Table", tb.getColumnExpression( ) ) );
			tableBindings.push( tb );
		}

		startCase( table );
	}

	public void startTableBand( ITableBandContent band )
	{

	}

	/**
	 * Add table's group information
	 * @param group
	 * 			current table group
	 */

	public void startTableGroup( ITableGroupContent group )
	{
		GroupInfo parent = (GroupInfo) groupInfos.peek( );
		String groupName = ( (TableGroupDesign) group.getGenerateBy( ) )
				.getName( );
		// to maintain the interrelation
		GroupInfo child = new GroupInfo( groupName, parent.getColExps( ) );
		parent.addSubGroupInfo( child );

		groupInfos.push( child );

	}

	public void startText( ITextContent text )
	{
	}

	/**
	 * Add an element's data to container.
	 * 
	 * @param design
	 *            element's design
	 * @param style
	 *            element's style
	 * @param url
	 *            url defined on element
	 * @param txt
	 *            element's value
	 */

	private void addData( Object design, IStyle style, String url, String txt )
	{
		Span span = (Span) design2ExcelSpan.get( design );

		if ( span == null )
		{
			return;
		}

		//Try to calculate the element's style
		StyleEntry entry = engine.getStyle( style, span );

		//store dataes
		Data data = new Data( txt, INVALID, span, url, entry );
		for ( int col = span.getCol( ); col < span.getCol( )
				+ span.getColSpan( ) + 1; col++ )
		{
			lb.add( col, data );
		}

		//calculate the table bind information.
		if ( design instanceof DataItemDesign && tableBindings.size( ) > 0 )
		{
			TableBinding tb = (TableBinding) tableBindings.peek( );

			if ( tb.isAggregateData( design ) )
			{
				tb.add2DataList( design, data );
			}
			else
			{
				GroupInfo groupInfo = (GroupInfo) groupInfos.peek( );
				int index = tb.getDataItemDesignIndex( design );
				groupInfo.addPosition( index, span.getCol( ), lb
						.getListSize( span.getCol( ) ) );
			}
		}
	}

	private int getMaxLenght( int from, int to )
	{
		int max = lb.getListSize( from );

		for ( int i = from + 1; i < to + 1; i++ )
		{
			if ( lb.getListSize( i ) > max )
			{
				max = lb.getListSize( i );
			}
		}

		return max;
	}

	private String parseHyperLink( IContent content )
	{
		IHyperlinkAction linkaction = content.getHyperlinkAction( );
		if ( linkaction != null )
		{
			if ( linkaction.getType( ) == IHyperlinkAction.ACTION_BOOKMARK )
			{
				return linkaction.getBookmark( ).replaceAll( " ", "_" );
			}
			else if ( linkaction.getType( ) == IHyperlinkAction.ACTION_HYPERLINK )
			{
				return linkaction.getHyperlink( );
			}
			else if ( linkaction.getType( ) == IHyperlinkAction.ACTION_DRILLTHROUGH )
			{
				Action act = new Action( linkaction );
				IHTMLActionHandler actionHandler = null;
				Object ac = eservice
						.getOption( RenderOptionBase.ACTION_HANDLER );

				if ( ac != null && ac instanceof IHTMLActionHandler )
				{
					actionHandler = (IHTMLActionHandler) ac;
					actionHandler.getURL( act, null );
					return actionHandler.getURL( act, eservice
							.getReportContext( ) );

				}
			}
		}
		return null;
	}

	/**
	 *  synchronize to make all columns's size is same.  
	 * 
	 */

	private void synchronizeCols( )
	{
		Span span = engine.getContainerSpan( );

		int from = span.getCol( );
		int to = from + span.getColSpan( );

		int max = getMaxLenght( from, to );

		for ( int i = from; i < to + 1; i++ )
		{
			while ( lb.getListSize( i ) < max )
			{
				lb.add( i, new Data( EMPTY, INVALID, new Span( i, 0 ), null,
						engine.createHorizionStyle( i ) ) );
			}
		}
	}

	private void writeDatas( ExcelWriter writer )
	{
		try
		{
			Object[] os;
			lb.open( );

			writer.startRow( );
			writer.endRow( );

			while ( lb.more( ) )
			{
				writer.startRow( );

				os = lb.readLine( );
				for ( int i = 0; i < os.length; i++ )
				{
					Data d = (Data) os[i];

					Object o = formulaDatas.get( d );
					if ( o != null )
					{
						Data x = (Data) o;
						d.isTxtData = x.isTxtData;
						d.txt = x.txt;
					}
					if ( d.isTxtData )
					{
						writer.writeTxtData( d );
					}
					else
					{
						writer.writeFormulaData( d );
					}

					i += d.span.getColSpan( );
				}

				writer.endRow( );
			}

			lb.close( );
		}
		catch ( Exception e )
		{
			logger.log( Level.WARNING, e.getMessage( ), e );
			throw new RuntimeException( "fail to read temp file" );
		}
	}
}
